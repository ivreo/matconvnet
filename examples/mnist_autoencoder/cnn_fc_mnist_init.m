function net = cnn_fc_mnist_init()

global learningRate;
global numEpochs;
global layerType;
global iters;
global decodingIdx;

rng('default');
rng(0) ;

% Meta parameters
net.meta.inputSize = [1 1 28^2] ;
net.meta.trainOpts.learningRate = learningRate ;
net.meta.trainOpts.numEpochs = numEpochs ;
net.meta.trainOpts.batchSize = 128 ;
net.meta.trainOpts.tiedFilters = 0;

% Architecture
sz = [1,1,28^2,1024];

net.layers = {} ;
switch layerType
    case 'THR'
        f = sqrt(2 / prod(sz(1:3)));
        net.layers{end+1} = struct('type', 'conv', ...
                                   'weights', {{f*randn(sz, 'single'), zeros(sz(4),1,'single')}}, ...
                                   'stride', 1, ...
                                   'pad', 0) ;
        net.layers{end+1} = struct('type', 'relu') ;
    case 'IT'
        net.layers{end+1} = struct('type', 'IT', ...
                                   'weights', {{randn(sz, 'single'), zeros(sz(4),1,'single')}}, ...
                                   'pad', 0, ...
                                   'stride', 1, ...
                                   'dilate', 1, ...
                                   'iters', iters, ...
                                   'stepsize', 2, ...
                                   'eigvec', [], ...
                                   'inputSize', net.meta.inputSize) ;
        encodingIdx = length(net.layers);
        [~,eigval] = vl_nnPowerMethod( ...
          [], ...
          net.layers{end}.weights{1}, ...
          net.layers{end}.pad, ...
          net.layers{end}.stride, ...
          net.layers{end}.dilate, ...
          net.layers{end}.inputSize, ...
          {'CuDNN'});
        f = 1 / sqrt(eigval) * sqrt(1.95 / net.layers{end}.stepsize) ;
        net.layers{end}.weights{1} = f * net.layers{end}.weights{1} ;
                               
                               
        net.layers{end+1} = struct('type', 'picklast', ...
                                   'iters', iters, ...
                                   'precious', true);
end
net.layers{end+1} = struct('type', 'convt', ...
                           'weights', {{f*randn(sz, 'single'), []}}, ...
                           'stride', 1, ...
                           'pad', 0) ;
                       
decodingIdx = length(net.layers);

net.layers{end+1} = struct('type', 'pdist', ...
                           'p', 2, ...
                           'noRoot', true, ...
                           'aggregate', true) ;

if strcmp(layerType,'IT')
    net.layers{encodingIdx}.tiedFilters = decodingIdx;
    net.layers{decodingIdx}.tiedFilters = encodingIdx;
end

% Fill in defaul values
net = vl_simplenn_tidy(net) ;

